

oop
객체지향프로그래밍

객체란 속성과 기능의 집합

정형화
비정형데이터를 정형화 함,
resource > java



## 1. 객체지향 프로그래밍(OOP)에서의 차이

| 구분          | Attribute                             | Property                                 |
| ----------- | ------------------------------------- | ---------------------------------------- |
| 정의          | 객체가 가진 실제 데이터(변수)                     | 데이터를 제어하거나 가공하여 반환하는 접근 메서드              |
| 형태          | 클래스 내부의 멤버 변수(field)로 존재              | getter﻿ / setter﻿ 같은 메서드를 통해 값 접근        |
| 기능          | 단순히 “저장된 값”을 보유                       | 접근 시 추가 로직(검증, 계산 등)이 수행됨                |
| 예시 (Python) | `self.name = "Tom"` → name은 attribute | `@property def age(): …` → age는 property |
| 예시 (Java)   | `private int radius;` (attribute)     | `public int getRadius()` (property)      |

**핵심 요약**

- Attribute는 **객체의 상태(State)**를 구성하는 “데이터 그 자체”이다.
    
- Property는 **해당 데이터를 다루는 인터페이스(Interface)**로, 외부 접근 시 내부 데이터를 안전하게 제어한다.[](https://www.tutorialspoint.com/what-is-the-difference-between-attributes-and-properties-in-python)​

( ) 조건식, 매서드
{ } 블록
[ ] 차원
< > 타입, 자료구조


HTML 에서 속성 Attribute
OOP 에서 속성 Property

parameter


오버로딩(Overloading)﻿과 오버라이딩(Overriding)﻿은 모두 **객체지향 프로그래밍(OOP)**에서 “다형성(polymorphism)”을 구현하기 위한 개념이지만,  
**적용 범위와 동작 시점, 목적**이 다르다.[](https://woo0doo.tistory.com/15)​

---

## 1. 개념 비교

|구분|오버로딩 (Overloading)|오버라이딩 (Overriding)|
|---|---|---|
|정의|같은 이름의 메서드를 **매개변수(개수·타입)가 다르게** 여러 개 정의하는 것|상속받은 부모 클래스의 메서드를 **자식 클래스에서 재정의**하는 것|
|위치|**같은 클래스 내부**|**상속 관계(부모 ↔ 자식 클래스)**|
|실행 시점|컴파일 시점(정적 바인딩)|실행 시점(동적 바인딩)|
|목적|같은 동작을 다양한 방식으로 수행|상속받은 기능을 수정하거나 확장|
|메서드 시그니처|이름은 같지만 매개변수 구성 다름|이름, 매개변수, 반환형 모두 동일해야 함|
|접근 제어자|아무 제약 없음|부모보다 더 강한 제한 불가|
|반환형|다를 수 있음|부모 메서드와 같아야 함|
|대표 키워드|“하나의 이름에 여러 기능”|“기존 메서드의 재정의”|


객체 지향 프로그래밍(OOP)의 4대 특징은

1 캡슐화  -  은닉화 @bean getter setter 
2 상속  -   속성의 상속
3 다형성  -  overriding  다양한 타입
4 추상화  -  기능의 상속

타입은 클래스/ 인터페이스


oop는 상추다 
은닉화 상속 추상화 다형성

attribute 초기값?! html 에 기록된 정적인 값 게터세터 없음
property 동작중일때의 실제값?! 브라우저 실행중 관리 하는 실시간 값 게터세터 있음


구상매서드
추상매서드

CRUD

## 1. CQRS의 의미

CQRS는 **Command and Query Responsibility Segregation**의 약자이다.  
이를 직역하면 **명령(Command)과 조회(Query)의 책임 분리**이다.

|구분|역할|설명|
|---|---|---|
|**Command**|데이터 쓰기|Create, Update, Delete 등 시스템의 상태를 변경하는 작업|
|**Query**|데이터 읽기|저장된 데이터를 조회하거나 가져오는 작업|

전통적인 CRUD 방식에서는 “하나의 데이터 모델”이  
읽기와 쓰기를 모두 담당하지만, CQRS에서는 **두 개의 독립된 모델로 분리한다**.[](https://azderica.github.io/02-architecture-msa/)​

---

## 2. 왜 분리할까?

CRUD 구조는 간단하지만 복잡해질수록 다음과 같은 단점이 생긴다:

- **읽기·쓰기 성능 요구사항이 다름**
    
- **읽기 전용 요청이 많을수록 DB 부하 증가**
    
- **하나의 모델에 서로 다른 책임 혼재 → 유지보수 어려움**
    

이를 해결하기 위해 CQRS는 책임을 다음처럼 분할한다:[](https://littlemobs.com/blog/cqrs-pattern-introduction/)​

- **Command 모델**: 데이터의 무결성과 비즈니스 규칙을 담당 (주로 트랜잭션 중심)
    
- **Query 모델**: 빠르고 효율적인 조회에 집중 (조회용 전용 DB나 캐시 사용 가능)
    

결과적으로 **확장성(Scalability)**과 **성능(Performance)**을 높이고,  
**복잡도(Complexity)**를 줄이는 효과가 있다.

=========  데이터의 변화 기준으로 구분



login 은 auth 에서만 

스프링(Spring)에서 **@GetMapping, @PostMapping, @PutMapping, @DeleteMapping**은  
각각 **CRUD 동작(Create, Read, Update, Delete)**에 대응하는 **HTTP 요청 방식**을 처리하기 위한 컨트롤러 매핑 어노테이션이다.[](https://masterpiece-programming.tistory.com/223)​

---

## 1. CRUD와 HTTP 메서드의 관계

|CRUD 동작|HTTP 메서드|스프링 어노테이션|역할|
|---|---|---|---|
|**Create (생성)**|POST|`@PostMapping`|클라이언트가 서버에 새 데이터를 생성 요청|
|**Read (조회)**|GET|`@GetMapping`|저장된 데이터를 조회하거나 화면에 표시|
|**Update (수정)**|PUT, PATCH|`@PutMapping`, `@PatchMapping`|기존 데이터를 수정하거나 일부 변경|
|**Delete (삭제)**|DELETE|`@DeleteMapping`|특정 데이터를 삭제 요청|

즉, **CRUD = Create·Read·Update·Delete**이고  
각 매핑 어노테이션은 이 네 동작을 **HTTP 규약에 맞게 구분해주는 라벨 역할**을 한다.[](https://jjangadadcodingdiary.tistory.com/entry/Spring-Spring-Framework%EC%97%90%EC%84%9C%EC%9D%98-PostMapping%EA%B3%BC-GetMapping-REST-API%EC%9D%98-%ED%95%B5%EC%8B%AC-%EC%9A%94%EC%86%8C)​

---

## 2. @GetMapping — **조회(READ)**

- 클라이언트가 서버에 **정보를 요청(GET)**할 때 사용
    
- 주로 브라우저 주소창, 링크 클릭, 페이지 로드 등에서 발생
    
- URL 파라미터를 통해 데이터 전달 (`localhost:8080/users?id=1`)
    

java

`@GetMapping("/users/{id}") public ResponseEntity<User> getUser(@PathVariable Long id) {     User user = userService.findUser(id);     return ResponseEntity.ok(user); }`

**특징**

- 서버의 상태를 바꾸지 않음 (조회 전용)
    
- 캐싱이 가능하고, 보안상 중요한 정보 전달엔 부적절.[](https://masterpiece-programming.tistory.com/223)​
    

---

## 3. @PostMapping — **생성(CREATE)**

- 클라이언트가 서버에 **새 데이터를 전송(POST)**할 때 사용
    
- 주로 회원가입, 글 작성, 댓글 등록 등에서 사용
    

java

`@PostMapping("/users") public ResponseEntity<User> createUser(@RequestBody User user) {     User savedUser = userService.createUser(user);     return ResponseEntity.ok(savedUser); }`

**특징**

- 데이터가 **HTTP Body**에 포함되어 전송 (보안성 ↑)
    
- 서버에 새로운 리소스를 추가하거나 상태를 변경함.[](https://unit-15.tistory.com/149)​
    

---

## 4. @PutMapping / @PatchMapping — **수정(UPDATE)**

- 기존 데이터를 **교체(PUT)**하거나 **일부 수정(PATCH)**할 때 사용
    
- `PUT`은 전체 교체, `PATCH`는 일부 속성만 업데이트
    

java

`@PutMapping("/users/{id}") public ResponseEntity<User> updateUser(@PathVariable Long id, @RequestBody User user) {     User updatedUser = userService.updateUser(id, user);     return ResponseEntity.ok(updatedUser); }`

**특징**

- 리소스를 완전히 갱신할 때 주로 사용
    
- `PATCH`는 REST API에서 점진적 변경 시 유용.[](https://james-coding-study.tistory.com/69)​
    

---

## 5. @DeleteMapping — **삭제(DELETE)**

- 특정 데이터를 **삭제 요청**할 때 사용
    

java

`@DeleteMapping("/users/{id}") public ResponseEntity<Void> deleteUser(@PathVariable Long id) {     userService.deleteUser(id);     return ResponseEntity.noContent().build(); }`

**특징**

- 서버 리소스를 제거함
    
- RESTful한 설계에서 "삭제"의 표준.[](https://velog.io/@dyunge_100/Spring-%EC%9A%94%EC%B2%AD-%EB%B0%A9%EC%8B%9DRequestMapping-GetMapping-PostMapping)​
    

---

## 6. CRUD 매핑 흐름 요약

|기능|어노테이션|HTTP Method|예시 요청 URL|설명|
|---|---|---|---|---|
|**Create**|`@PostMapping`|POST|`/api/users`|새 데이터 등록|
|**Read (전체 조회)**|`@GetMapping`|GET|`/api/users`|데이터 목록 조회|
|**Read (단일 조회)**|`@GetMapping`|GET|`/api/users/{id}`|특정 데이터 조회|
|**Update**|`@PutMapping`|PUT|`/api/users/{id}`|기존 데이터 수정|
|**Delete**|`@DeleteMapping`|DELETE|`/api/users/{id}`|데이터 삭제|

---

## 7. 핵심 정리

- `@RequestMapping(method = RequestMethod.XYZ)`를 간결히 표현한 버전이  
    `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`이다.
    
- CRUD에 대응되는 명확한 HTTP 메서드를 사용함으로써  
    **RESTful API 설계 원칙을 따르는 깔끔하고 직관적 코드**가 된다.[](https://jjangadadcodingdiary.tistory.com/entry/Spring-Spring-Framework%EC%97%90%EC%84%9C%EC%9D%98-PostMapping%EA%B3%BC-GetMapping-REST-API%EC%9D%98-%ED%95%B5%EC%8B%AC-%EC%9A%94%EC%86%8C)​
    

---

즉,

- **GET → 조회(Read)**
    
- **POST → 생성(Create)**
    
- **PUT/PATCH → 수정(Update)**
    
- **DELETE → 삭제(Delete)**
    

이 네 어노테이션이 스프링에서 **CRUD를 HTTP 요청 방식으로 구분해 주는 컨트롤러의 핵심 구성요소**이다.[](https://james-coding-study.tistory.com/69)​스프링(Spring)에서 **@GetMapping, @PostMapping, @PutMapping, @DeleteMapping**은  
각각 **CRUD 동작(Create, Read, Update, Delete)**에 대응하는 **HTTP 요청 방식**을 처리하기 위한 컨트롤러 매핑 어노테이션이다.[](https://masterpiece-programming.tistory.com/223)​

---

## 1. CRUD와 HTTP 메서드의 관계

|CRUD 동작|HTTP 메서드|스프링 어노테이션|역할|
|---|---|---|---|
|**Create (생성)**|POST|`@PostMapping`|클라이언트가 서버에 새 데이터를 생성 요청|
|**Read (조회)**|GET|`@GetMapping`|저장된 데이터를 조회하거나 화면에 표시|
|**Update (수정)**|PUT, PATCH|`@PutMapping`, `@PatchMapping`|기존 데이터를 수정하거나 일부 변경|
|**Delete (삭제)**|DELETE|`@DeleteMapping`|특정 데이터를 삭제 요청|

즉, **CRUD = Create·Read·Update·Delete**이고  
각 매핑 어노테이션은 이 네 동작을 **HTTP 규약에 맞게 구분해주는 라벨 역할**을 한다.[](https://jjangadadcodingdiary.tistory.com/entry/Spring-Spring-Framework%EC%97%90%EC%84%9C%EC%9D%98-PostMapping%EA%B3%BC-GetMapping-REST-API%EC%9D%98-%ED%95%B5%EC%8B%AC-%EC%9A%94%EC%86%8C)​

---

## 2. @GetMapping — **조회(READ)**

- 클라이언트가 서버에 **정보를 요청(GET)**할 때 사용
    
- 주로 브라우저 주소창, 링크 클릭, 페이지 로드 등에서 발생
    
- URL 파라미터를 통해 데이터 전달 (`localhost:8080/users?id=1`)
    

java

`@GetMapping("/users/{id}") public ResponseEntity<User> getUser(@PathVariable Long id) {     User user = userService.findUser(id);     return ResponseEntity.ok(user); }`

**특징**

- 서버의 상태를 바꾸지 않음 (조회 전용)
    
- 캐싱이 가능하고, 보안상 중요한 정보 전달엔 부적절.[](https://masterpiece-programming.tistory.com/223)​
    

---

## 3. @PostMapping — **생성(CREATE)**

- 클라이언트가 서버에 **새 데이터를 전송(POST)**할 때 사용
    
- 주로 회원가입, 글 작성, 댓글 등록 등에서 사용
    

java

`@PostMapping("/users") public ResponseEntity<User> createUser(@RequestBody User user) {     User savedUser = userService.createUser(user);     return ResponseEntity.ok(savedUser); }`

**특징**

- 데이터가 **HTTP Body**에 포함되어 전송 (보안성 ↑)
    
- 서버에 새로운 리소스를 추가하거나 상태를 변경함.[](https://unit-15.tistory.com/149)​
    

---

## 4. @PutMapping / @PatchMapping — **수정(UPDATE)**

- 기존 데이터를 **교체(PUT)**하거나 **일부 수정(PATCH)**할 때 사용
    
- `PUT`은 전체 교체, `PATCH`는 일부 속성만 업데이트
    

java

`@PutMapping("/users/{id}") public ResponseEntity<User> updateUser(@PathVariable Long id, @RequestBody User user) {     User updatedUser = userService.updateUser(id, user);     return ResponseEntity.ok(updatedUser); }`

**특징**

- 리소스를 완전히 갱신할 때 주로 사용
    
- `PATCH`는 REST API에서 점진적 변경 시 유용.[](https://james-coding-study.tistory.com/69)​
    

---

## 5. @DeleteMapping — **삭제(DELETE)**

- 특정 데이터를 **삭제 요청**할 때 사용
    

java

`@DeleteMapping("/users/{id}") public ResponseEntity<Void> deleteUser(@PathVariable Long id) {     userService.deleteUser(id);     return ResponseEntity.noContent().build(); }`

**특징**

- 서버 리소스를 제거함
    
- RESTful한 설계에서 "삭제"의 표준.[](https://velog.io/@dyunge_100/Spring-%EC%9A%94%EC%B2%AD-%EB%B0%A9%EC%8B%9DRequestMapping-GetMapping-PostMapping)​
    

---

## 6. CRUD 매핑 흐름 요약

|기능|어노테이션|HTTP Method|예시 요청 URL|설명|
|---|---|---|---|---|
|**Create**|`@PostMapping`|POST|`/api/users`|새 데이터 등록|
|**Read (전체 조회)**|`@GetMapping`|GET|`/api/users`|데이터 목록 조회|
|**Read (단일 조회)**|`@GetMapping`|GET|`/api/users/{id}`|특정 데이터 조회|
|**Update**|`@PutMapping`|PUT|`/api/users/{id}`|기존 데이터 수정|
|**Delete**|`@DeleteMapping`|DELETE|`/api/users/{id}`|데이터 삭제|

---

## 7. 핵심 정리

- `@RequestMapping(method = RequestMethod.XYZ)`를 간결히 표현한 버전이  
    `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`이다.
    
- CRUD에 대응되는 명확한 HTTP 메서드를 사용함으로써  
    **RESTful API 설계 원칙을 따르는 깔끔하고 직관적 코드**가 된다.[](https://jjangadadcodingdiary.tistory.com/entry/Spring-Spring-Framework%EC%97%90%EC%84%9C%EC%9D%98-PostMapping%EA%B3%BC-GetMapping-REST-API%EC%9D%98-%ED%95%B5%EC%8B%AC-%EC%9A%94%EC%86%8C)​
    

---

즉,

- **GET → 조회(Read)**
    
- **POST → 생성(Create)**
    
- **PUT/PATCH → 수정(Update)**
    
- **DELETE → 삭제(Delete)**
    

이 네 어노테이션이 스프링에서 **CRUD를 HTTP 요청 방식으로 구분해 주는 컨트롤러의 핵심 구성요소**이다.[](https://james-coding-study.tistory.com/69)​

스프링(Spring)에서 **@GetMapping, @PostMapping, @PutMapping, @DeleteMapping**은  
각각 **CRUD 동작(Create, Read, Update, Delete)**에 대응하는 **HTTP 요청 방식**을 처리하기 위한 컨트롤러 매핑 어노테이션이다.[](https://masterpiece-programming.tistory.com/223)​

---

## 1. CRUD와 HTTP 메서드의 관계

| CRUD 동작         | HTTP 메서드   | 스프링 어노테이션                      | 역할                      |
| --------------- | ---------- | ------------------------------ | ----------------------- |
| **Create (생성)** | POST       | `@PostMapping`                 | 클라이언트가 서버에 새 데이터를 생성 요청 |
| **Read (조회)**   | GET        | `@GetMapping`                  | 저장된 데이터를 조회하거나 화면에 표시   |
| **Update (수정)** | PUT, PATCH | `@PutMapping`, `@PatchMapping` | 기존 데이터를 수정하거나 일부 변경     |
| **Delete (삭제)** | DELETE     | `@DeleteMapping`               | 특정 데이터를 삭제 요청           |

즉, **CRUD = Create·Read·Update·Delete**이고  
각 매핑 어노테이션은 이 네 동작을 **HTTP 규약에 맞게 구분해주는 라벨 역할**을 한다.



![[Pasted image 20251023160116.png]]

이게 기본  JPA  전자정부 표준

/id/{id}  ==>> path


