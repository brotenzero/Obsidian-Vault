

docker run cogirihub my-postgres \
  -e POSTGRES_PASSWORD=12341234 \
  -d postgres

매핑 이기종언어 연결

notation
annotation


## 🧩 1️⃣ 스프링 컨텍스트란?

👉 쉽게 말해서  
**“스프링이 만든 객체들을 모두 모아놓은 공장(또는 창고)”** 입니다.

---

### ✅ 예를 들어 볼게요

당신이 카페 사장이라고 생각해봅시다 ☕

- 바리스타, 캐셔, 매니저 같은 직원들이 있죠.
    
- 사장은 직접 직원 하나하나를 매번 “new”로 뽑지 않아요.  
    대신 “인사팀(Spring)”이 알아서 사람을 관리해줍니다.
    

이때 “인사팀(Spring)”이 바로 **스프링 컨텍스트**예요.  
스프링이 대신 객체(Bean)를 만들어두고 필요할 때 꺼내쓰게 해주는 거죠.

---

## 🧠 2️⃣ 어노테이션이 하는 일

어노테이션은 스프링에게 **“이건 관리해야 하는 객체야!”** 라고 **표시를 붙이는 역할**을 합니다.

즉, 스프링이

> “어떤 클래스를 공장에 등록해야 하지?”  
> 라고 고민할 때,  
> 클래스 위에 있는 **@Component**, **@Service**, **@Controller** 같은 어노테이션을 보고 판단합니다.



### 동작 흐름 요약:

1. 프로그램 실행 시, 스프링이 코드를 스캔함.
    
2. `@Component`, `@Service`, `@Repository`, `@Controller` 등을 찾음.
    
3. 해당 클래스들을 스프링 컨텍스트에 **Bean**으로 등록함.
    
4. 다른 클래스에서 `@Autowired` 등을 통해 주입받아 사용함.


JPA 는 규격(표준)이고 실제일은 Hibernate 가 한다
interface                               implements


JPA 
run 하면 어노테이션을 먼저 읽음

JPA jpa = new hibernate() >> 내가생성한 코드는 사라짐

인프라 구축을 위해
어노테이션으로 만듦


싱글톤객체
프로그램 전체에서 단 하나만 존재하는 객체
전역(공통부모) 어디서든 쓸수 있음

어노테이션은 싱글톤 객체를 만든다



스키마를 자동생성해야 스프링이 인식함

좋아요 👍 아주 좋은 질문이에요!  
이 네 가지(`HTML`, `XML`, `YML`, `ZML`)는 **모두 “데이터를 표현하는 언어”**들이지만,  
**목적과 문법 구조가 완전히 다릅니다.**

초보자도 한눈에 구분할 수 있도록  
👉 **비유 + 예시 코드 + 표 정리**로 설명드릴게요 👇

---

## 🧩 1️⃣ 먼저 한 줄 요약

| 언어             | 전체 이름                                 | 주요 용도         | 사람 vs 컴퓨터 | 구조      |
| -------------- | ------------------------------------- | ------------- | --------- | ------- |
| **HTML**       | HyperText Markup Language             | 웹페이지 화면 표시    | 브라우저가 읽음  | 태그 기반   |
| **XML**        | eXtensible Markup Language            | 데이터 저장/교환     | 프로그램이 읽음  | 태그 기반   |
| **YML / YAML** | YAML Ain’t Markup Language            | 설정(config) 파일 | 사람이 읽기 쉽게 | 들여쓰기 기반 |
| **ZML**        | (보통 _Zope Markup Language_ 등, 드물게 사용) | 특수 목적 XML 확장  | 특정 툴 전용   | 태그 기반   |
xml data-interchange fromat
json

soup 방식과 rest 방식의 차이점을 알려줘

###### ChatGPT의 말:

좋아요 😄 정말 좋은 질문이에요!  
“**SOAP 방식**과 **REST 방식**”은 **웹 서비스(Web Service)**를 구현하는 **두 가지 다른 통신 방식**이에요.  
둘 다 “서버와 클라이언트가 데이터를 주고받는 방법”이지만,  
**철학도 다르고, 사용하는 기술도 완전히 다릅니다.**
 
초보자도 확실히 이해할 수 있게 👇  
👉 비유 + 구조 + 예시 + 표로 깔끔하게 정리해드릴게요.

---

## 🧩 1️⃣ 먼저 핵심 차이 한 줄 요약

|구분|**SOAP**|**REST**|
|---|---|---|
|전체 이름|Simple Object Access Protocol|Representational State Transfer|
|핵심 개념|**규칙이 매우 엄격한** 메시지 기반 통신|**HTTP를 그대로 활용하는** 간단한 방식|
|데이터 포맷|XML만 사용|JSON, XML, YAML 등 자유|
|구조|복잡한 프로토콜 (헤더, 바디 등)|URL과 HTTP 메서드(GET, POST 등) 기반|
|대표 예시|옛날 금융/정부 시스템|웹 API, 모바일 백엔드, 현대 웹서비스|

---

## ☕️ 2️⃣ 비유로 쉽게 이해하기

### 🔹 SOAP = 우체국 공식 서류 📦

- 편지를 보낼 때 정해진 양식이 있어요.  
    (봉투 규격, 주소 형식, 우표 위치, 인감 등)
    
- 규칙을 엄격히 따라야만 접수됩니다.
    
- 대신, 안정적이고 신뢰성 높아요.
    

### 🔹 REST = 이메일 ✉️

- 자유롭게 보낼 수 있어요.
    
- 빠르고 간단하고, 형식도 유연합니다.
    
- 대신, 보낸 사람이 규칙을 잘 안 지키면 오류가 날 수도 있어요.
    

---

## 🧠 3️⃣ SOAP 방식

> SOAP은 **XML 기반의 통신 규격(protocol)**이에요.  
> 데이터를 보낼 때 “SOAP Envelope(봉투)” 형식으로 감쌉니다.

### ✅ SOAP 메시지 예시

`<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">   <soap:Header/>   <soap:Body>     <getUserRequest>       <userId>123</userId>     </getUserRequest>   </soap:Body> </soap:Envelope>`

### 💡 특징

- 반드시 XML 사용
    
- 요청/응답 구조가 고정되어 있음
    
- 주로 **WSDL(Web Services Description Language)** 파일을 통해 서비스 설명
    
- 보안, 트랜잭션, 오류 처리 등 내장 기능이 많음
    
- 무겁고 복잡하지만 **신뢰성과 표준화**가 필요할 때 강함 (예: 은행, 공공기관)
    

---

## 🌐 4️⃣ REST 방식

> REST는 **HTTP 프로토콜을 그대로 사용**하는 “원칙”이에요.  
> 별도의 포맷 없이 URL + HTTP 메서드(GET, POST, PUT, DELETE)로 데이터 주고받습니다.

### ✅ REST 요청 예시

`GET https://api.example.com/users/123`

### ✅ REST 응답 예시 (JSON)

`{   "id": 123,   "name": "Alice" }`

### 💡 특징

- **단순함 (Simple)** — HTTP 자체를 활용
    
- **유연함 (Flexible)** — JSON, XML, 등 어떤 데이터도 가능
    
- **가볍고 빠름**
    
- **표준 규약은 없지만, 개발자 간 약속으로 작동**
    
- 현대 웹/앱 API 대부분이 REST 기반 (ex: Google, Kakao, GitHub API)
    

---

## ⚙️ 5️⃣ 실제 비교 예시

|항목|**SOAP**|**REST**|
|---|---|---|
|**데이터 포맷**|XML 고정|JSON, XML, 등 자유|
|**통신 방식**|자체 프로토콜 (HTTP 외에도 SMTP 등 가능)|HTTP 기반|
|**표준 정의 파일**|WSDL (필수)|없음|
|**보안**|WS-Security 등 고급 기능 지원|HTTPS로 단순 처리|
|**속도**|상대적으로 느림|빠름|
|**유연성**|낮음|높음|
|**적합한 곳**|은행, 결제, 정부 시스템|일반 웹서비스, 앱 API|

---

## 🧩 6️⃣ 예를 들어볼게요

**SOAP 버전**

`POST /userService HTTP/1.1 Content-Type: text/xml  <soap:Envelope>   <soap:Body>     <getUser>       <id>1</id>     </getUser>   </soap:Body> </soap:Envelope>`

**REST 버전**

`GET /users/1 HTTP/1.1 Accept: application/json`

---

## 🚀 7️⃣ 요약 정리

|비교 항목|SOAP|REST|
|---|---|---|
|**형식**|프로토콜 (엄격한 규칙)|아키텍처 스타일 (유연한 원칙)|
|**데이터 형식**|XML만 가능|JSON, XML, YAML 등|
|**속도/단순성**|느리고 복잡함|빠르고 간단함|
|**보안/표준성**|강력한 보안·트랜잭션|단순한 HTTPS 수준|
|**대표 사용처**|은행, 공공기관|웹·모바일 서비스|

---

## ✅ 한 줄 요약

> 🧾 **SOAP** = 규칙 많은 “공식 문서형” 통신 (신뢰성↑, 복잡도↑)  
> 🌐 **REST** = 자유로운 “웹 API형” 통신 (간단함↑, 유연성↑)

---

원하신다면 “같은 기능을 SOAP과 REST로 각각 구현한 코드 예시(Java Spring 기준)”도 보여드릴까요?  
직접 비교하면 둘의 철학이 눈에 확 들어옵니다 👀



-- SOCCER_SQL_011
-- 팀과 스타디움을 조인하여
-- 스타디움, 팀이름 출력
-- 연고지가 없는 팀은 팀명만 나오고
-- 스타디움은 20개 다 출력되고
-- 홈팀이 없으면 해당 팀명에 "홈팀이 없음" 출력
-- 참고로 팀은 총 15개

select * from team;
select * from stadium;

SELECT 
    st.stadium_name,
    COALESCE(t.team_name, '홈팀이 없음') AS 팀이름
FROM stadium st
LEFT JOIN team t
    ON st.hometeam_id = t.team_id
ORDER BY st.stadium_name;



-- SOCCER_SQL_012
-- 팀과 스타디움, 스케줄을 조인하여
-- 2012년 3월 17일에 열린 각 경기의
-- 팀이름, 스타디움, 어웨이팀 이름 출력
-- 다중테이블 join 을 찾아서 해결하시오.

SELECT 
    t.team_name 홈팀, 
    st.stadium_name 경기장, 
    a.team_name 원정팀
FROM schedule sc
JOIN stadium st USING (stadium_id)
JOIN team t ON sc.hometeam_id = t.team_id
JOIN team a ON sc.awayteam_id = a.team_id
WHERE sc.sche_date = '2012-03-17';


-- SOCCER_SQL_013
-- 2012년 3월 17일 경기에
-- 포항 스틸러스 소속 골키퍼(GK)
-- 선수, 포지션,팀명 (연고지포함),
-- 스타디움, 경기날짜를 구하시오
-- 연고지와 팀이름은 간격을 띄우시오
SELECT 
    p.player_name 선수,
    p.position 포지션,
    CONCAT(t.region_name, ' ', t.team_name) 팀명,
    st.stadium_name 경기장,
    sc.sche_date 경기날짜
FROM player p
JOIN team t 
    ON p.team_id = t.team_id
JOIN schedule sc
    ON p.team_id = sc.hometeam_id 
       OR p.team_id = sc.awayteam_id
JOIN stadium st 
    ON sc.stadium_id = st.stadium_id
WHERE sc.sche_date = '2012-03-17'
  AND t.team_name = '스틸러스'
  AND p.position = 'GK';                                                                                      


-- SOCCER_SQL_014
-- 홈팀이 3점이상 차이로 승리한 경기의
-- 경기장 이름, 경기 일정
-- 홈팀 이름과 원정팀 이름을
-- 구하시오
SELECT 
    st.stadium_name 경기장,
    sc.sche_date 경기일정,
    t_home.team_name 홈팀,
    t_away.team_name 원정팀
FROM schedule sc
JOIN stadium st USING (stadium_id)
JOIN team t_home ON sc.hometeam_id = t_home.team_id
JOIN team t_away ON sc.awayteam_id = t_away.team_id
WHERE sc.home_score - sc.away_score >= 3
ORDER BY sc.sche_date;


-- SOCCER_SQL_015
-- STADIUM 에 등록된 운동장 중에서
-- 홈팀이 없는 경기장까지 전부 나오도록
-- 카운트 값은 20

select * from stadium;

select
	st.stadium_name,
	st.stadium_id,
	st.seat_count,
	st.hometeam_id,
	t.e_team_name
from stadium st
left join team t on st.hometeam_id = t.team_id



### ✅ 예시 2: 올바른 Collation 설정 (한국어용)

한국어 Collation을 설정한 DB는 이렇게 만들어야 해요:

`CREATE DATABASE soccerdb   WITH ENCODING 'UTF8'   LC_COLLATE='ko_KR.utf8'   LC_CTYPE='ko_KR.utf8';`